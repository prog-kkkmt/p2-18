# Выполнил:Степаненко Кирилл 
# Группа: П2-18
# Создание классов
# Оператор class создает новое определение класса. Имя класса сразу следует
# за ключевым словом class, после которого ставиться двоеточие:
# Пример создания класса
class Employee:
    '''Базовый класс для всех сотрудников'''
    # кол-во сотрудников
    emp_count = 0
    # это конструктор класса
    def __init__(self, name, salary):
        self.name = name
        self.salary = salary
        Employee.emp_count += 1
        # методы класса
    def display_count(self):
        print('Всего сотрудников : %d' % Employee.emp_count)
    def display_employee(self):
        print('Имя: {}, зарплата: {}'.format(self.name, self.salary))
    # Создание экземпляров класса

# Это создаст первый объект класса Employee
emp1 = Employee('Andrey', 2000)
print(emp1)
# Доступ к атрибутам
# Получите доступ к атрибутам класса, используя оператор '.' после объекта #класса.
# Доступ к классу можно получить используя имя переменой класса:

emp2 = Employee('Maria', 5000)
emp1.display_employee()
emp2.display_employee()
print('All people: %d' % Employee.emp_count)
# Вместо использования привычных операторов для доступа к атрибутам вы #можете
# использовать эти функции:

# getattr(obj, name [, default]) — для доступа к атрибуту объекта.
# hasattr(obj, name) — проверить, есть ли в obj атрибут name.
# setattr(obj, name, value) — задать атрибут. Если атрибут не существует,
# он будет создан.
# delattr(obj, name) — удалить атрибут

print()
setattr(emp1, 'age', 8)  # устанавливает атрибут 'age' на 8
print(emp1.age)
print(hasattr(emp1, 'age'))  # возвращает true если атрибут 'age' существует
print(getattr(emp1, 'age'))  # возвращает значение атрибута 'age'
delattr(emp1, 'age')  # удаляет атрибут 'age'
# Встроенные атрибуты класса
# Каждый класс Python хранит встроенные атрибуты, и предоставляет к ним
# доступ через оператор ., как и любой другой атрибут
# __dict__ — словарь, содержащий пространство имен класса.
# __doc__ — строка документации класса. None если, документация отсутствует.
# __name__ — имя класса.
# __module__ — имя модуля, в котором определяется класс. Этот атрибут #__main__
#             в интерактивном режиме.
# __bases__ — могут быть пустые tuple, содержащие базовые классы, в порядке
#            их появления в списке базового класса.

print()
print('Employee.__doc__:', Employee.__doc__)
print('Employee.__name__:', Employee.__name__)
print('Employee.__module__:', Employee.__module__)
print('Employee.__bases__:', Employee.__bases__)
print('Employee.__dict__:', Employee.__dict__)
# Уничтожение объектов (сбор мусора)

# Python автоматически удаляет ненужные объекты (встроенные типы или #экземпляры
# классов), чтобы освободить пространство памяти. С помощью процесса #‘Garbage
# Collection’ Python периодически восстанавливает блоки памяти, которые #больше
# не используются.

# Сборщик мусора Python запускается во время выполнения программы и тогда,
# когда количество ссылок на объект достигает нуля. С изменением количества
# обращений к нему, меняется количество ссылок.

# Когда объект присваивают новой переменной или добавляют в контейнер #(список,
# кортеж, словарь), количество ссылок объекта увеличивается. Количество #ссылок
# на объект уменьшается, когда он удаляется с помощью del, или его ссылка
# выходит за пределы видимости. Когда количество ссылок достигает нуля, #Python
# автоматически собирает его.

a = 40  # создали объект <40>
b = a  # увеличивает количество ссылок  <40>
c = [b]  # увеличивает количество ссылок <40>
del a  # уменьшает количество ссылок <40>
b = 100  # уменьшает количество ссылок <40>
c[0] = -1  # уменьшает количество ссылок <40>

# классом можно реализовать специальный метод __del__(),
# называемый деструктором.

class Point:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y
    def __del__(self):
        class_name = self.__class__.__name__
        print('{} destroyed'.format(class_name))

pt1 = Point()
pt2 = pt1
pt3 = pt1
print()
print(id(pt1), id(pt2), id(pt3))
del pt1
del pt2
del pt3