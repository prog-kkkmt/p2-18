import random
import math

'''
Цель Функционального  программирования: Допустим ты разработчик и у тебя есть уже готовый продукт состоящий из 1000 
строк кода, казалось бы, такую программу можно написать в обычном стиле, который не привязан к функциям(ФП) или 
Объектам(ООП) но внезапно обнаруживается баг а ведь ты сидя над исправлением багов месяц думал что этого не могло 
случиться, и если ты не писал код с помощью функция то скорее всего ты будешь смотреть много кода, и об игре в кс можешь 
забыть, но в ФП ты бы понял  с легкость какая из твоих функций косячит и накуканил бы ее на верный код, к тому же 
функции можно использовать многоразово и вообще импортировать

'''


#######################################################################################################################
def sum(a, b):  # Тупая изи функция Детерминированная
    return a + b


print(sum(3, 6))
print(sum(3, 6))

#######################################################################################################################
print(random.random())  # Тупая не Детерминированная Функция (При одних и тех же локальных условиях
# значения могут быть разные)

#######################################################################################################################
sos = [32, 3, 50, 2, 29, 43]


def sort_by_sort(z):  # Функция с побочкой она грязная, тк она изменяет начальный список и  печатает его в консоль
    z.sort()
    print(z)


sort_by_sort(sos)


#####################################

def smart_sort_by_sorted(spiska):  # Функция без побочки
    return sorted(spiska)

    # мы с помощью принта печатаем функцию и тем самым мы печатаем ЗНАЧЕНИЕ КОТОРОЕ ЭТА ФУНКЦИЯ ВОЗВРАЩАЕТ(return)


e = smart_sort_by_sorted(sos)
print(e)


#######################################################################################################################

def ФукцияОбычная(num):  # Функция высшего порядка
    return num ** 2


print(ФукцияОбычная(4))


#####################################

def ФункцияСложная(fun, num):
    return fun(num) + fun(num)


print(ФункцияСложная(ФукцияОбычная, 4))

#######################################################################################################################

# Lambda Функции
'''            говорим ей данные для крафта
         Ключевое слово |        Командуем'''
''' Выводим     |       |  Затем   |    Она подставляет в Аргумент значение которое указаны здесь, первому первое'''
'''    |        |       |     |    |       | '''                                                  '''Значение и тд'''
'''    |        |       |     |    |       | '''
'''   print((lambda АРГУМЕНТЫ : КРАФТ)(ЗНАЧЕНИЯ))'''
# import math

ОкругленноеПИ = round(math.pi, 2)  # 3,14


# Площадь круга
def area(radius):
    return ОкругленноеПИ * (radius ** 2)  # PI*R^2


print(area(5))

# Теперь запишем ввиде lambda  функции

print((lambda home: ОкругленноеПИ * (home ** 2))(5))

# Объем усеченного конуса :
print(
    (lambda Ширина, РадиусБ, РадиусМ: (Ширина * ОкругленноеПИ * (РадиусБ ** 2 + РадиусБ * РадиусМ + РадиусМ ** 2)) / 3)(
        15, 10, 6))

#######################################################################################################################

Chisla = [43, 23, 56, 75, 12, 32]
print(sorted(Chisla))

Strochanki = ['zum6z', '0ybt0', 'h1uwq', '2k9f9', 'hin9h', 'b0p0m']
print(sorted(Strochanki))
# Если партия требует сложную сортировку:
bookses = [
    {'title': 'Game of Thrones', 'published': '1996-08-01', 'pages': 694},
    {'title': 'Clash of Kings', 'published': '1998-11-16', 'pages': 761},
    {'title': 'Storm of Swords', 'published': '2000-08-08', 'pages': 973},
    {'title': 'Feast for Crows', 'published': '2005-10-17', 'pages': 753},
    {'title': 'Dance with Dragons', 'published': '2011-07-12', 'pages': 1016}
]


def title(book):
    return book.get('title')


bookses.sort(key=title)
for i in bookses:
    print(i)


def publish_date(book):
    return book.get('published')


bookses.sort(key=publish_date)
for i in bookses:
    print(i)


def pages(book):
    return book.get('pages')


bookses.sort(key=pages)
for i in bookses:
    print(i)

# Сортируем по датам

bookses.sort(key=publish_date)
for i in bookses:
    print(i)

# Сортируем по количеству страниц

bookses.sort(key=pages)
for i in bookses:
    print(i)
# Ещё кое что:
# s.sort(key=lambda x: x[1])
'''s.sort(key = lambda x: x[1])'''
