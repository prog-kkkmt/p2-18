Выполнили: Короленко И.Р., Кузнецов М.С., Слесарев А.М.
Группа: ККМТ П2-18

[1] Упражнения раздела 2.5
1) Упражнение 2.24. Какие из следующих определений (если они есть) недопустимы? Почему? Как их исправить?
(a)	int ival = 1.01;
(b) int &rvall = 1.01;
(с)	int &rval2 = ival;
(d) const int &rval3 = 1;

	Ответ: 
		b и d неверные,  ссылки должны ссылаться на объект.

2) Упражнение 2.25. Какие из следующих присвоений (если они есть) являются недопустимыми 
(с учетом предыдущих определений)? Если таковые есть, объясните, почему.
(а)	rva12 = 3.14159;
(b) rva12 = rva13;
(с)	ival = rval3;
(d) rval3 = ival;

	Ответ: 
		d, так как  rval3 - константа и не может быть изменена.

3) Упражнение 2.26. В чем разница между определениями (а) и присвоениями (Ь)? 
Какие из них (если есть) недопустимы?
(a)	int ival = 0;	(b) ival = ri;
const int &ri =0;	ri = ival;

	Ответ: 
		А,  ссылка должна инициализироваться объектом.


4) Упражнение 2.27. Что отобразит на экране следующий код?
int i, &ri = i; i = 5; ri = 10;
std::cout << i << " " << ri << std::endl;

  Данный код выведет следующие значения на экран: 10 10.

[1] Упражнения раздела 4.2.3
5) Упражнение 4.15. Укажите принципиальные различия между указателями и ссылками.
	Ответ:
		1. Указатель может быть переназначен любое количество раз, в то время как ссылка после привязки не может быть перемещена на другую ячейку памяти.
		2. Указатели могут указывать "в никуда" (быть равными NULL), в то время как ссылка всегда указывает на определенный объект. GCC может без выдачи предупреждений обработать код наподобие int &x = *(int*)0;, однако поведение подобного кода может быть непредсказуемым.
		3. Вы не можете получить адрес ссылки, как можете это делать с указателями.
		4. Не существует арифметики ссылок, в то время как существует арифметика указателей. Однако есть возможность получить адрес объекта, указанного по ссылке, и применить к этому адресу арифметику указателей (например &obj + 5).

[1] Упражнения раздела 7.2.2
6) Упражнение 7.7. Объясните различие между параметрами в следующих двух объявлениях.
void f(Т);
void f(Т&);

	Ответ: 
		В 1-м случае используется значение переменной в функции.
		А во 2-м  - адрес переменной.	

7) Упражнение 7.8. Приведите пример случая, когда параметр должен быть ссылочным.
Приведите пример случая, когда параметр не должен быть ссылочным.

	Ответ: когда параметр должен быть ссылочным:

void swap(int *v1, int *v2){
   int temp = *v1;
   *v1 = *v2;
   *v2 = temp;
}

Тогда она будет вызываться следующим образом:

swap(&i, &j);

void swap(int &v1, int &v2){
   int temp = v1;
   v1 = v2;
   v2 = temp;
}

В этом случае вызов будет выглядеть так:

swap(i, j);

8) Упражнение 7.10. Следующая функция хоть и вполне допустима, но менее полезна,
чем могла бы быть. Выявите и устраните ограничения.
bool test(string& s) { return s.empty(); } Написать main для аргументации своего решения

	

9) Упражнение 7.11. Когда ссылочные параметры должны быть константными? 
Какие проблемы могут возникнуть, если параметр является обычной ссылкой, 
а какие — если он является константной ссылкой?

	Ответ:
		1. Параметры, не изменяющие значение аргумента, должны быть константными ссылками.
		2. В функцию с обычной ссылкой нельзя передать символьный строковый литерал.
		3. Когда аргументами являются большие структуры или классы, процесс может занять много времени.
